<!-- 5 minutes only!!!! -->
<!-- start with intro/brief background from oli, 2.5 minutes -->
<!-- then alex will talk about brief implementation and results/conclusions, 2.5 minutes -->

# intro: oli (~2.5 min)

## what is qram? (~45 sec)

<!-- [slide: title slide - "fat-tree qram: a high-bandwidth shared quantum memory architecture"] -->

hi! today we're presenting our work reproducing and validating fat-tree qram.

so what is qram? quantum random access memory lets quantum algorithms query a classical database in superposition. you give it an address register in superposition, and it returns the corresponding data values entangled with each address.

this is critical because many important quantum algorithms assume qram exists and just count queries. without efficient qram, these algorithms can't deliver their promised speedups.

---

## bucket-brigade qram (~1 min 15 sec)

the standard qram design is bucket-brigade qram. the key building block is a quantum router.

<!-- [slide: show bb_qram_figure.jpg part (b) - single router diagram] -->

each router has four ports—input at the top, a route register that stores a routing decision, and left/right outputs going to child routers. the key operation is the controlled-swap: if the route bit is 0, we swap the input toward the left child; if it's 1, toward the right.

<!-- [slide: show bb_qram_figure.jpg part (c) - the h-tree layout] -->

bucket-brigade arranges these routers in a binary tree above the memory cells. here's the layout for n=8—circles are routers, data cells are at the bottom. the red routers are "active"—meaning they've received an address bit and are ready to route.

<!-- [slide: show bb_qram_figure.jpg part (a) - query execution phases] -->

to perform an actual query using this structure: first, address bits load down through the tree, each bit getting stored at successive levels to activate routers along one path. then a bus qubit descends to the leaves, picks up data via x gates, and returns. finally address bits unload. the whole thing takes o(log n) depth.

the key insight is that even for superposition queries, each branch only activates one path—so errors scale as o(log² n), not o(n). this is what makes it practical.

---

## the bandwidth problem (~20 sec)

but there's a catch. when one query is running, it occupies routers along the entire root-to-leaf path. if you have multiple clients wanting to query simultaneously, they have to wait. for p queries, total time becomes o(p log n). qram becomes a bandwidth bottleneck.

---

## fat-tree solution (~25 sec)

<!-- [slide: show fat_tree_figure.jpg - the full fat-tree structure for N=32] -->

fat-tree qram solves this by adding extra copies of routers. you can see each node now contains multiple routers—the different colors show different "layers." a scheduling protocol lets queries move through these layers as they progress, so they don't block each other.

this means up to o(log n) queries can be in flight simultaneously, completing in o(log n) total time—giving you o(1) amortized latency per query. the trade-off is about 2 times more routers.

---

# implementation & results: alex (~2.5 min)


<!-- [slide: portion of circuit diagram for N=2 Fat-Tree QRAM] -->

we used qiskit to implement both the Fat-Tree QRAM and the BB QRAM

this allowed us to generate a graph representation of the created circuit, allowing us to trace the correct execution of the algorithms
when no errors due to noise occur, while also being able to simulate the results.

<!-- [slide: show IBM quantum suite layout or somet] -->

Due to the limited size of IBM's quantum computers available through qiskit, we were only able to test QRAM sizes up to n=4 as these trees
already required 100 qubits and the size of the IBM computers were a maximum of 156

<!-- [slide: show test results table for simulation] -->

In these tests we initialised the qubits at every address to 0, other than the last address which we set for 1.
We then tried to extract the final address from the QRAM so a success would be measuring 1 on the data qubit after retrieval.


<!-- [slide: show equations giving increased qubits] -->

These equations show the difference in the number of qubits required for BB and Fat-Tree QRAM and they show how Fat-Tree requires
slightly less than double the number of qubits as BB QRAM requires.

<!-- [slide: show equations for increased number of swaps] -->

These equations show how the number of swaps required in Fat-Tree QRAM is dramatically highere than in BB QRAM due to the Swap-i
and Swap-ii stages in the Fat-Tree algorith that swaps qubits between routers.

<!-- [slide: conclusion] -->

In conclusion, while the simulator we used did not have good enough error rates to give better results, we were able to verify many
of the claims by the paper through analysis of the circuits generated by their algorithms.


---
